According to the "Introduction to dplyr" vignette written by the package authors, "The
dplyr philosophy is to have small functions that each do one thing well."
Specifically, dplyr supplies five 'verbs' that cover most fundamental data manipulation tasks:
select(), filter(), arrange(), mutate(), and summarize()

# Select()

## As may often be the case, particularly with larger datasets, we are only interested in
some of the variables. 
## Use select(cran, ip_id, package, country) to select only the
ip_id, package, and country variables from the cran dataset.

> select(cran, ip_id, package, country)
# A tibble: 225,468 x 3
   ip_id package      country
   <int> <chr>        <chr>  
 1     1 htmltools    US     
 2     2 tseries      US     
 3     3 party        US     
 4     3 Hmisc        US     
 5     4 digest       CA     
 6     3 randomForest US     
 7     3 plyr         US     
 8     5 whisker      US     
 9     6 Rcpp         CN     
10     7 hflights     US     
# … with 225,458 more rows

The first thing to notice is that we don't have to type cran$ip_id, cran$package, and
cran$country, as we normally would when referring to columns of a data frame. The
select() function knows we are referring to columns of the cran dataset.
                                                 
Also, note that the columns are returned to us in the order we specified, even though
ip_id is the rightmost column in the original dataset.

Recall that in R, the `:` operator provides a compact notation for creating a sequence
of numbers. For example, try 5:20
> 5:20
 [1]  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20
 
Normally, this notation is reserved for numbers, but select() allows you to specify a
sequence of columns this way, which can save a bunch of typing. Use select(cran, r_arch:country) to select 
all columns starting from r_arch and ending with country.

> select(cran, r_arch:country)
# A tibble: 225,468 x 5
   r_arch r_os      package      version country
   <chr>  <chr>     <chr>        <chr>   <chr>  
 1 x86_64 mingw32   htmltools    0.2.4   US     
 2 x86_64 mingw32   tseries      0.10-32 US     
 3 x86_64 linux-gnu party        1.0-15  US     
 4 x86_64 linux-gnu Hmisc        3.14-4  US     
 5 x86_64 linux-gnu digest       0.6.4   CA     
 6 x86_64 linux-gnu randomForest 4.6-7   US     
 7 x86_64 linux-gnu plyr         1.8.1   US     
 8 x86_64 linux-gnu whisker      0.3-2   US     
 9 NA     NA        Rcpp         0.10.4  CN     
10 x86_64 linux-gnu hflights     0.1     US     
# … with 225,458 more rows


We can also select the same columns in reverse order.

> select(cran, country:r_arch)
# A tibble: 225,468 x 5
   country version package      r_os      r_arch
   <chr>   <chr>   <chr>        <chr>     <chr> 
 1 US      0.2.4   htmltools    mingw32   x86_64
 2 US      0.10-32 tseries      mingw32   x86_64
 3 US      1.0-15  party        linux-gnu x86_64
 4 US      3.14-4  Hmisc        linux-gnu x86_64
 5 CA      0.6.4   digest       linux-gnu x86_64
 6 US      4.6-7   randomForest linux-gnu x86_64
 7 US      1.8.1   plyr         linux-gnu x86_64
 8 US      0.3-2   whisker      linux-gnu x86_64
 9 CN      0.10.4  Rcpp         NA        NA    
10 US      0.1     hflights     linux-gnu x86_64
# … with 225,458 more rows

Instead of specifying the columns we want to keep, we can also specify the columns we
want to throw away. To see how this works, do select(cran, -time) to omit the time
column.

> select(cran, -time)
# A tibble: 225,468 x 10
       X date          size r_version r_arch r_os      package      version country ip_id
   <int> <chr>        <int> <chr>     <chr>  <chr>     <chr>        <chr>   <chr>   <int>
 1     1 2014-07-08   80589 3.1.0     x86_64 mingw32   htmltools    0.2.4   US          1
 2     2 2014-07-08  321767 3.1.0     x86_64 mingw32   tseries      0.10-32 US          2
 3     3 2014-07-08  748063 3.1.0     x86_64 linux-gnu party        1.0-15  US          3
 4     4 2014-07-08  606104 3.1.0     x86_64 linux-gnu Hmisc        3.14-4  US          3
 5     5 2014-07-08   79825 3.0.2     x86_64 linux-gnu digest       0.6.4   CA          4
 6     6 2014-07-08   77681 3.1.0     x86_64 linux-gnu randomForest 4.6-7   US          3
 7     7 2014-07-08  393754 3.1.0     x86_64 linux-gnu plyr         1.8.1   US          3
 8     8 2014-07-08   28216 3.0.2     x86_64 linux-gnu whisker      0.3-2   US          5
 9     9 2014-07-08    5928 NA        NA     NA        Rcpp         0.10.4  CN          6
10    10 2014-07-08 2206029 3.0.2     x86_64 linux-gnu hflights     0.1     US          7
# … with 225,458 more rows

The negative sign in front of time tells select() that we DON'T want the time column.
Now, let's combine strategies to omit all columns from X through size (X:size). To see
how this might work, let's look at a numerical example with -5:20.

> -5:20
 [1] -5 -4 -3 -2 -1  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20
 
 Oops! That gaves us a vector of numbers from -5 through 20, which is not what we want.
Instead, we want to negate the entire sequence of numbers from 5 through 20, so that
we get -5, -6, -7, ... , -18, -19, -20. Try the same thing, except surround 5:20 with
parentheses so that R knows we want it to first come up with the sequence of numbers,
then apply the negative sign to the whole thing.

-(5:20) will do the job.

> -(5:20)
 [1]  -5  -6  -7  -8  -9 -10 -11 -12 -13 -14 -15 -16 -17 -18 -19 -20

Use this knowledge to omit all columns X:size using select().

Use select(cran, -(X:size)) to omit all columns from X through size.

> select(cran, -(X:size))
# A tibble: 225,468 x 7
   r_version r_arch r_os      package      version country ip_id
   <chr>     <chr>  <chr>     <chr>        <chr>   <chr>   <int>
 1 3.1.0     x86_64 mingw32   htmltools    0.2.4   US          1
 2 3.1.0     x86_64 mingw32   tseries      0.10-32 US          2
 3 3.1.0     x86_64 linux-gnu party        1.0-15  US          3
 4 3.1.0     x86_64 linux-gnu Hmisc        3.14-4  US          3
 5 3.0.2     x86_64 linux-gnu digest       0.6.4   CA          4
 6 3.1.0     x86_64 linux-gnu randomForest 4.6-7   US          3
 7 3.1.0     x86_64 linux-gnu plyr         1.8.1   US          3
 8 3.0.2     x86_64 linux-gnu whisker      0.3-2   US          5
 9 NA        NA     NA        Rcpp         0.10.4  CN          6
10 3.0.2     x86_64 linux-gnu hflights     0.1     US          7
# … with 225,458 more rows

# filter()

## Now that you know how to select a subset of columns using select(), a natural next
question is "How do I select a subset of rows?" That's where the filter() function
comes in.

Use filter(cran, package == "swirl") to select all rows for which the package variable
is equal to "swirl". Be sure to use two equals signs side-by-side!

> filter(cran, package == "swirl")
# A tibble: 820 x 11
       X date     time      size r_version r_arch r_os      package version country ip_id
   <int> <chr>    <chr>    <int> <chr>     <chr>  <chr>     <chr>   <chr>   <chr>   <int>
 1    27 2014-07… 00:17:… 105350 3.0.2     x86_64 mingw32   swirl   2.2.9   US         20
 2   156 2014-07… 00:22:…  41261 3.1.0     x86_64 linux-gnu swirl   2.2.9   US         66
 3   358 2014-07… 00:13:… 105335 2.15.2    x86_64 mingw32   swirl   2.2.9   CA        115
 4   593 2014-07… 00:59:… 105465 3.1.0     x86_64 darwin13… swirl   2.2.9   MX        162
 5   831 2014-07… 00:55:… 105335 3.0.3     x86_64 mingw32   swirl   2.2.9   US         57
 6   997 2014-07… 00:33:…  41261 3.1.0     x86_64 mingw32   swirl   2.2.9   US         70
 7  1023 2014-07… 00:35:… 106393 3.1.0     x86_64 mingw32   swirl   2.2.9   BR        248
 8  1144 2014-07… 00:00:… 106534 3.0.2     x86_64 linux-gnu swirl   2.2.9   US        261
 9  1402 2014-07… 00:41:…  41261 3.1.0     i386   mingw32   swirl   2.2.9   US        234
10  1424 2014-07… 00:44:… 106393 3.1.0     x86_64 linux-gnu swirl   2.2.9   US        301
# … with 810 more rows

Again, note that filter() recognizes 'package' as a column of cran, without you having
to explicitly specify cran$package.

The == operator asks whether the thing on the left is equal to the thing on the right.
If yes, then it returns TRUE. If no, then FALSE. In this case, package is an entire
vector (column) of values, so package == "swirl" returns a vector of TRUEs and FALSEs.
filter() then returns only the rows of cran corresponding to the TRUEs.

| You can specify as many conditions as you want, separated by commas. For example
| filter(cran, r_version == "3.1.1", country == "US") will return all rows of cran
| corresponding to downloads from users in the US running R version 3.1.1. Try it out.

> filter(cran, r_version == "3.1.1", country == "US")
# A tibble: 1,588 x 11
       X date     time     size r_version r_arch r_os     package   version country ip_id
   <int> <chr>    <chr>   <int> <chr>     <chr>  <chr>    <chr>     <chr>   <chr>   <int>
 1  2216 2014-07… 00:48… 3.85e5 3.1.1     x86_64 darwin1… colorspa… 1.2-4   US        191
 2 17332 2014-07… 03:39… 1.97e5 3.1.1     x86_64 darwin1… httr      0.3     US       1704
 3 17465 2014-07… 03:25… 2.33e4 3.1.1     x86_64 darwin1… snow      0.3-13  US         62
 4 18844 2014-07… 03:59… 1.91e5 3.1.1     x86_64 darwin1… maxLik    1.2-0   US       1533
 5 30182 2014-07… 04:13… 7.77e4 3.1.1     i386   mingw32  randomFo… 4.6-7   US        646
 6 30193 2014-07… 04:06… 2.35e6 3.1.1     i386   mingw32  ggplot2   1.0.0   US          8
 7 30195 2014-07… 04:07… 2.99e5 3.1.1     i386   mingw32  fExtremes 3010.81 US       2010
 8 30217 2014-07… 04:32… 5.68e5 3.1.1     i386   mingw32  rJava     0.9-6   US         98
 9 30245 2014-07… 04:10… 5.27e5 3.1.1     i386   mingw32  LPCM      0.44-8  US          8
10 30354 2014-07… 04:32… 1.76e6 3.1.1     i386   mingw32  mgcv      1.8-1   US       2122
# … with 1,578 more rows











